<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>배드민턴 코트 배정 시스템 (v5.1 - Fix)</title>
    <style>
        /* --- (CSS는 v5와 동일) --- */
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; background-color: #f4f4f9; display: flex; justify-content: center; align-items: center; padding: 20px; flex-direction: column; -webkit-font-smoothing: antialiased; }
        .container { width: 100%; max-width: 1200px; margin: 0 auto; }
        .global-controls { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; background-color: #fff; padding: 15px 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); margin-bottom: 20px; }
        .global-controls .control-group { display: flex; align-items: center; gap: 8px; }
        .global-controls label { font-weight: bold; font-size: 0.9rem; }
        .global-controls button, .control-group button { padding: 10px 15px; background-color: #007aff; color: white; border: none; border-radius: 5px; font-size: 0.9rem; font-weight: bold; cursor: pointer; transition: background-color 0.2s; }
        .global-controls button:hover, .control-group button:hover { background-color: #0056b3; }
        .global-controls input[type="time"], .global-controls input[type="file"] { border: 1px solid #ccc; border-radius: 5px; padding: 5px 8px; }
        .global-controls input[type="file"] { display: none; }
        .global-controls #csvLoadButton { background-color: #34c759; }
        .global-controls #csvLoadButton:hover { background-color: #2a9e48; }
        /* [삭제] 다운로드 버튼 스타일 제거 */
        .global-controls #clearMasterTime { background-color: #eee; color: #555; padding: 5px 8px; font-size: 0.8rem; }
        .global-controls #clearMasterTime:hover { background-color: #ddd; }
        .courts-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .court { position: relative; display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; gap: 5px; background-color: #333; border: 12px solid #e0e0e0; border-radius: 5px; padding: 5px; }
        .court-number { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80px; height: 40px; background-color: #555; color: white; border-radius: 20px; display: flex; justify-content: center; align-items: center; font-size: 1.1rem; font-weight: bold; z-index: 10; pointer-events: none; transition: background-color 0.3s; }
        .court-number.playing { background-color: #34c759; font-family: 'Menlo', 'Monaco', 'Courier New', monospace; font-size: 1.25rem; }
        .player-slot { background-color: #f0f0f0; color: #aaa; display: flex; justify-content: center; align-items: center; min-height: 80px; font-size: 0.9rem; font-weight: bold; cursor: pointer; transition: background-color 0.2s, transform 0.1s; user-select: none; z-index: 1; border: 2px dashed transparent; }
        .player-slot.filled { background-color: #fbc2c2; color: #c93a3a; font-weight: bold; }
        .player-slot.drag-over { background-color: #d4ffd4; border-color: #34c759; transform: scale(1.03); }
        .wait-item.dragging { opacity: 0.4; transform: scale(0.95); }
        .waitlist-section { background-color: #f2e8e8; padding: 20px; border-radius: 10px; }
        .waitlist-section h3 { margin: 0 0 20px 0; font-size: 1.5rem; color: #333; }
        .add-player-form { display: flex; gap: 10px; margin-bottom: 20px; }
        .add-player-form input[type="text"] { flex-grow: 1; padding: 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 1rem; }
        .add-player-form button { padding: 10px 20px; background-color: #5a8d5a; color: white; border: none; border-radius: 5px; font-size: 1rem; font-weight: bold; cursor: pointer; }
        .add-player-form button:hover { background-color: #4a744a; }
        .waiting-list { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 10px; list-style: none; padding: 0; margin: 0; }
        .wait-item { display: flex; justify-content: space-between; align-items: center; background: #fdf6f6; padding: 10px 15px; border-radius: 5px; border: 1px solid #e0c8c8; cursor: grab; transition: opacity 0.2s, transform 0.2s; }
        .wait-item:active { cursor: grabbing; }
        .wait-item .player-name { font-weight: bold; font-size: 1.1rem; color: #333; }
        .wait-item .wait-time { background: #eee; padding: 5px 8px; border-radius: 3px; font-size: 0.9rem; font-weight: bold; color: #555; min-width: 60px; text-align: right; }
        .wait-item .assign-btn { padding: 5px 10px; font-size: 0.8rem; background-color: #4a76c2; color: white; border: none; border-radius: 3px; cursor: pointer; margin-left: 5px; }
        .wait-item .assign-btn:hover { background-color: #3a5d9a; }
    </style>
</head>
<body>

    <div class="container">
        
        <div class="global-controls">
            <div class="control-group">
                <button id="addCourtButton">➕ 코트 추가</button>
            </div>
            
            <div class="control-group">
                <input type="file" id="csvFileInput" accept=".csv, text/csv">
                <button id="csvLoadButton" onclick="document.getElementById('csvFileInput').click();">
                    📄 CSV 명단 불러오기
                </button>
            </div>
            
            <div class="control-group time-control">
                <label for="masterStartTime">대표 시작 시간:</label>
                <input type="time" id="masterStartTime">
                <button id="clearMasterTime" title="대표 시작 시간 지우기">❌</button>
            </div>
        </div>

        <div class="courts-container" id="courtsContainer">
            </div>
        
        <div class="waitlist-section">
            <h3>대기 명단 & 대기 시간 표시</h3>
            <div class="add-player-form">
                <input type="text" id="playerNameInput" placeholder="대기자 이름 입력...">
                <button id="addPlayerButton">대기열 추가</button>
            </div>
            <ul class="waiting-list" id="waitingList"></ul>
        </div>

    </div>

    <script>
        // --- JavaScript (v5.1 - Fix) ---

        // 1. 필요한 HTML 요소들을 가져옵니다.
        const playerNameInput = document.getElementById('playerNameInput');
        const addPlayerButton = document.getElementById('addPlayerButton');
        const waitingListElement = document.getElementById('waitingList');
        const courtsContainer = document.getElementById('courtsContainer');
        const addCourtButton = document.getElementById('addCourtButton');
        const masterStartTimeInput = document.getElementById('masterStartTime');
        const clearMasterTimeButton = document.getElementById('clearMasterTime');
        const csvFileInput = document.getElementById('csvFileInput');
        // [삭제] downloadListButton 상수 삭제

        // 2. 데이터 변수
        let waitingQueue = [];
        let nextId = 0;
        let courts = []; 

        // 3. (함수) 대기열 목록 렌더링 (v5와 동일)
        function renderWaitingList() {
            waitingListElement.innerHTML = '';
            const now = Date.now();
            waitingQueue.forEach(player => {
                const elapsedSeconds = Math.floor((now - player.startTime) / 1000);
                const minutes = Math.floor(elapsedSeconds / 60);
                const seconds = elapsedSeconds % 60;
                const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}초`;
                const li = document.createElement('li');
                li.className = 'wait-item';
                li.setAttribute('draggable', 'true');
                li.dataset.playerId = player.id;
                li.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', player.id);
                    e.dataTransfer.effectAllowed = 'move';
                    li.classList.add('dragging'); 
                });
                li.addEventListener('dragend', () => { li.classList.remove('dragging'); });
                li.innerHTML = `
                    <span class="player-name">${player.name}</span>
                    <span class="wait-time">${formattedTime}</span>
                    <button class="assign-btn" data-player-id="${player.id}">배정</button>
                `;
                waitingListElement.appendChild(li);
            });
        }
        
        // (함수) 코트 상태 렌더링 (v5와 동일)
        function renderCourtStatus() {
            const now = Date.now();
            courts.forEach(court => {
                let display = '대기';
                let isPlaying = false;
                if (court.status === 'playing') {
                    const elapsedSeconds = Math.floor((now - court.startTime) / 1000);
                    const minutes = Math.floor(elapsedSeconds / 60);
                    const seconds = elapsedSeconds % 60;
                    display = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                    isPlaying = true;
                }
                const courtElement = document.getElementById(`court-${court.id}`);
                const numberSpan = courtElement.querySelector('.court-number');
                numberSpan.textContent = display;
                numberSpan.classList.toggle('playing', isPlaying);
            });
        }

        // 4. (함수) 대기열에 새 플레이어 추가 (v5와 동일)
        function addPlayerToQueue(name, startTime) {
            if (!name || name.trim() === "") return;
            const newPlayer = { id: nextId++, name: name.trim(), startTime: startTime };
            waitingQueue.push(newPlayer);
        }
        
        // 4-1. (함수) '대기열 추가' 버튼 핸들러 (v5와 동일)
        function handleAddPlayerButton() {
            const name = playerNameInput.value;
            if (name.trim() === "") { alert("플레이어 이름을 입력하세요!"); return; }
            let startTime = Date.now(); 
            const masterTimeValue = masterStartTimeInput.value;
            if (masterTimeValue) {
                const [hours, minutes] = masterTimeValue.split(':').map(Number);
                const manualStartTime = new Date();
                manualStartTime.setHours(hours, minutes, 0, 0);
                if (manualStartTime.getTime() > Date.now()) { alert("대표 시작 시간은 현재 시간보다 미래일 수 없습니다."); return; }
                startTime = manualStartTime.getTime();
            }
            addPlayerToQueue(name, startTime);
            playerNameInput.value = '';
            renderWaitingList();
        }

        // (함수) 코트 상태 체크 (v5와 동일)
        function checkCourtStatus(courtId) {
            const court = courts.find(c => c.id == courtId);
            if (!court) return;
            const playerCount = court.players.filter(p => p !== null).length;
            if (playerCount === 4 && court.status === 'waiting') {
                court.status = 'playing';
                court.startTime = Date.now();
            } else if (playerCount < 4 && court.status === 'playing') {
                court.status = 'waiting';
                court.startTime = null;
            }
            renderCourtStatus();
        }

        // 5. [수정] (함수) 플레이어를 슬롯에 배정 (버그 수정됨)
        function assignPlayerById(playerId, targetSlot) {
            const playerIndex = waitingQueue.findIndex(p => p.id == playerId);
            if (playerIndex === -1) return;
            const player = waitingQueue[playerIndex];

            let slotToFill = targetSlot; // 드래그 시 targetSlot (DOM요소) / 버튼 클릭 시 null
            
            if (!slotToFill) { // 버튼 클릭 시 (slotToFill이 null일 때)
                const allSlots = document.querySelectorAll('.player-slot');
                for (const slot of allSlots) {
                    if (!slot.classList.contains('filled')) {
                        slotToFill = slot; // 빈 슬롯을 찾아서 slotToFill에 할당
                        break;
                    }
                }
            }
            
            if (!slotToFill) { alert("모든 코트가 꽉 찼습니다!"); return; }
            if (slotToFill.classList.contains('filled')) { alert("이미 플레이어가 배정된 슬롯입니다."); return; }

            // --- [핵심 버그 수정] ---
            // 'targetSlot'이 아닌, 빈 슬롯을 찾은 'slotToFill' 변수를 사용해야 함
            const courtId = slotToFill.dataset.court; 
            const slotIndex = parseInt(slotToFill.dataset.slot, 10) - 1;
            // ------------------------
            
            const court = courts.find(c => c.id == courtId);
            court.players[slotIndex] = player.name;
            
            slotToFill.classList.add('filled');
            slotToFill.textContent = player.name;
            slotToFill.dataset.playerName = player.name; 

            waitingQueue.splice(playerIndex, 1);
            renderWaitingList();
            
            checkCourtStatus(courtId);
        }
        
        // 6. (함수) 코트 슬롯 비우기 (v5와 동일)
        function clearSlot(event) {
            const slot = event.target; 
            if (slot.classList.contains('filled')) {
                const playerName = slot.dataset.playerName;
                if (confirm(`'${playerName}'님의 배정을 취소하고 대기열로 돌려보내시겠습니까?`)) {
                    const courtId = slot.dataset.court;
                    const slotIndex = parseInt(slot.dataset.slot, 10) - 1;
                    const court = courts.find(c => c.id == courtId);
                    court.players[slotIndex] = null; 
                    addPlayerToQueue(playerName, Date.now());
                    slot.classList.remove('filled');
                    slot.textContent = `플레이어 ${parseInt(slot.dataset.slot, 10)}`;
                    delete slot.dataset.playerName;
                    renderWaitingList(); 
                    checkCourtStatus(courtId);
                }
            }
        }

        // 7. (함수) 새 코트 추가 (v5와 동일)
        function addCourt() {
            const newCourtId = courts.length + 1;
            const newCourtData = { id: newCourtId, players: [null, null, null, null], status: 'waiting', startTime: null };
            courts.push(newCourtData);
            const newCourt = document.createElement('div');
            newCourt.className = 'court';
            newCourt.id = `court-${newCourtId}`;
            newCourt.innerHTML = `
                <span class="court-number">대기</span>
                <div class="player-slot" data-court="${newCourtId}" data-slot="1">플레이어 1</div>
                <div class="player-slot" data-court="${newCourtId}" data-slot="2">플레이어 2</div>
                <div class="player-slot" data-court="${newCourtId}" data-slot="3">플레이어 3</div>
                <div class="player-slot" data-court="${newCourtId}" data-slot="4">플레이어 4</div>
            `;
            courtsContainer.appendChild(newCourt);
        }
        
        // 8. (함수) CSV 파일 읽기 (v5와 동일)
        function handleCsvUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const text = e.target.result;
                const lines = text.split('\n');
                const startTime = Date.now();
                let addedCount = 0;
                lines.forEach(line => {
                    const name = line.trim();
                    if (name) { addPlayerToQueue(name, startTime); addedCount++; }
                });
                renderWaitingList();
                alert(`${addedCount}명의 플레이어가 대기열에 추가되었습니다.`);
                csvFileInput.value = ''; 
            };
            reader.onerror = () => { alert("파일을 읽는 중 오류가 발생했습니다."); };
            reader.readAsText(file);
        }
        
        // 9. [삭제] downloadWaitlistAsCsv 함수 삭제

        // --- 이벤트 리스너 연결 --- (다운로드 버튼 리스너만 삭제)
        addPlayerButton.addEventListener('click', handleAddPlayerButton);
        playerNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleAddPlayerButton(); });
        addCourtButton.addEventListener('click', addCourt);
        clearMasterTimeButton.addEventListener('click', () => { masterStartTimeInput.value = ''; });
        csvFileInput.addEventListener('change', handleCsvUpload);
        // [삭제] downloadListButton 이벤트 리스너 삭제

        waitingListElement.addEventListener('click', (e) => {
            if (e.target.classList.contains('assign-btn')) {
                const playerId = e.target.dataset.playerId;
                assignPlayerById(playerId, null);
            }
        });
        courtsContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('player-slot')) {
                clearSlot(e);
            }
        });
        // 드래그 앤 드롭 (v5와 동일)
        courtsContainer.addEventListener('dragover', (e) => {
            e.preventDefault(); 
            const targetSlot = e.target;
            if (targetSlot.classList.contains('player-slot') && !targetSlot.classList.contains('filled')) {
                targetSlot.classList.add('drag-over');
                e.dataTransfer.dropEffect = 'move';
            } else { e.dataTransfer.dropEffect = 'none'; }
        });
        courtsContainer.addEventListener('dragleave', (e) => {
            if (e.target.classList.contains('player-slot')) {
                e.target.classList.remove('drag-over');
            }
        });
        courtsContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            const targetSlot = e.target;
            targetSlot.classList.remove('drag-over'); 
            if (targetSlot.classList.contains('player-slot') && !targetSlot.classList.contains('filled')) {
                const playerId = e.dataTransfer.getData('text/plain');
                assignPlayerById(playerId, targetSlot);
            }
        });

        // --- 초기화 함수 --- (v5와 동일)
        function initializeApp() {
            for (let i = 0; i < 4; i++) { addCourt(); }
            waitingQueue = [
                { id: nextId++, name: '박성준', startTime: Date.now() - 10000 },
                { id: nextId++, name: '강준시', startTime: Date.now() - 20000 },
                { id: nextId++, name: '고도한', startTime: Date.now() - 30000 },
            ];
            renderWaitingList();
            renderCourtStatus();
        }

        // --- 메인 루프 --- (v5와 동일)
        setInterval(() => {
            renderWaitingList();
            renderCourtStatus();
        }, 1000);
        
        // 앱 실행
        initializeApp();

    </script>
</body>
</html>
